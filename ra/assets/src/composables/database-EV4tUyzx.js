var f=Object.defineProperty;var u=(e,t,s)=>t in e?f(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var r=(e,t,s)=>(u(e,typeof t!="symbol"?t+"":t,s),s);import{X as m}from"../../async-vendor-gRlujhSQ.js";import{i as p}from"../helpers/initialdbcontent-IvvUMyBB.js";import{R as y,F as l,C as d}from"./riskcatalog-hVdw2NQQ.js";const k="risk-assessment";class h extends m{constructor(){super(k);r(this,"equipment");r(this,"technicians");r(this,"risks");r(this,"factors");r(this,"categories");r(this,"measures");r(this,"riskassessments");r(this,"riskassessmentsmeta");r(this,"inputhistory");this.version(1).stores({equipment:"++id, descr, *causeRisks",technicians:"++id, name",risks:"++id, factorId, sector, descr",factors:"++id, categoryId, descr",categories:"++id, descr",measures:"++id, descr, *solveRisks, *causeRisks",riskassessments:"++id, descr, company, adress, startDate, endDate, address, jobDescr, *equipment, *technicians, *supervisors, *access, *risks, measures, meta",riskassessmentsmeta:"&id, descr, created, lastChange",inputhistory:"++id, &[inputId+text]"}),this.on("populate",s=>p(s)),this.on("ready",()=>{this.risks.mapToClass(y),this.factors.mapToClass(l),this.categories.mapToClass(d)})}}const D=new h;var g=(e=>(e.Access="Z",e.Environment="U",e.Work="A",e))(g||{});function c(e,t){for(let s in t){if(typeof t[s]!="object"){e[s]=t[s];continue}if(Array.isArray(t[s])){e[s]=[...t[s]];continue}if(e[s]===void 0&&(e[s]={}),typeof e[s]!="object")throw Error("can't merge incompatible objects");c(e[s],t[s])}}function O(e,t){return console.log(e),c(e,t),e}function a(e,t){if(typeof e!="object")return e;if(Array.isArray(e))return e.map(n=>a(n));if(e==null)return e;let s=Object.keys(e);t!==void 0&&(s=t);const i={};return s.forEach(n=>{i[n]=a(e[n])}),i}function o(e,t){if(typeof e!=typeof t)return!1;if(typeof e!="object")return e===t;if(Array.isArray(e)){if(!Array.isArray(t)||e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(!o(e[s],t[s]))return!1;return!0}if(Object.keys(e).length!==Object.keys(t).length)return!1;for(let s in t)if(!o(e[s],t[s]))return!1;return!0}function E(e,t){const s={};for(let i in t)s[i]=e[i];return s}export{g as S,a,o as b,D as d,O as m,E as p};
